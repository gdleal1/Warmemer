#version 330 core

// Fragment attributes received as input ("in") by the Fragment Shader.
// In this example, this attribute was generated by the rasterizer as the
// interpolation of the global position and the normal of each vertex, defined in
// "shader_vertex.glsl" and "main.cpp".
in vec4 position_world;
in vec4 normal;

// Position of the current vertex in the model's local coordinate system.
in vec4 position_model;

// Texture coordinates obtained from the OBJ file (if they exist!)
in vec2 texcoords;

// Matrices computed in the C++ code and sent to the GPU
uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

// Identifier that defines which object is currently being drawn
#define CONTAINER 0
#define PLANE  1
#define DREAD 2
#define ORCMECH 3
#define RUIN 4
uniform int object_id;

// Parameters of the model's axis-aligned bounding box (AABB)
uniform vec4 bbox_min;
uniform vec4 bbox_max;

// Variables for accessing texture images
uniform sampler2D TextureImage0;
uniform sampler2D TextureImage1;
uniform sampler2D TextureImage2;
uniform sampler2D TextureImage3;
uniform sampler2D TextureImage4;

// The output value (“out”) of a Fragment Shader is the final color of the fragment.
out vec4 color;

#define M_PI   3.14159265358979323846
#define M_PI_2 1.57079632679489661923

void main()
{
    // We obtain the camera's position using the inverse of the matrix that defines the
    // camera's coordinate system.
    vec4 origin = vec4(0.0, 0.0, 0.0, 1.0);
    vec4 camera_position = inverse(view) * origin;

    // The current fragment is covered by a point on the surface of one
    // of the virtual objects in the scene. This point, p, has a position in the
    // global coordinate system (World coordinates). This position is obtained
    // by the rasterizer interpolating the position of each
    // vertex.
    vec4 p = position_world;

    // Normal of the current fragment, interpolated by the rasterizer from the
    // normals of each vertex.
    vec4 n = normalize(normal);

    // Vector that defines the direction of the light source in relation to the current point.
    vec4 l = normalize(vec4(1.0,1.0,0.0,0.0));

    // Vector that defines the direction of the camera in relation to the current point.
    vec4 v = normalize(camera_position - p);

    // U and V texture coordinates
    float U = 0.0;
    float V = 0.0;
    vec3 Kd0 = vec3(1.0, 2.0, 1.0);

    // Lighting Equation
    float lambert = max(0,dot(n,l));
    vec4 reflect_dir = reflect(-l, n);
    float specular = pow(max(0, dot(reflect_dir, v)), 64.0);

    if ( object_id == CONTAINER ){

        // Cubic mapping: project onto the face with the largest component
        vec3 dir = normalize((position_model - (bbox_min + bbox_max) / 2.0).xyz);
        vec3 absDir = abs(dir);
        vec2 uv;
        if (absDir.x >= absDir.y && absDir.x >= absDir.z) {
            // X face
            uv = vec2(dir.z, dir.y) / absDir.x;
            U = (uv.x + 1.0) * 0.5;
            V = (uv.y + 1.0) * 0.5;
        } else if (absDir.y >= absDir.x && absDir.y >= absDir.z) {
            // Y face
            uv = vec2(dir.x, dir.z) / absDir.y;
            U = (uv.x + 1.0) * 0.5;
            V = (uv.y + 1.0) * 0.5;
        } else {
            // Z face
            uv = vec2(dir.x, dir.y) / absDir.z;
            U = (uv.x + 1.0) * 0.5;
            V = (uv.y + 1.0) * 0.5;
        }

        Kd0 = texture(TextureImage4, vec2(U, V)).rgb;
    }
    else if ( object_id == PLANE ){

        float minx = bbox_min.x;
        float maxx = bbox_max.x;

        float miny = bbox_min.y;
        float maxy = bbox_max.y;

        float minz = bbox_min.z;
        float maxz = bbox_max.z;

        U = (position_model.x - minx) / (maxx - minx);
        V = (position_model.z - minz) / (maxz - minz);
        
        Kd0 = texture(TextureImage2, vec2(U,V)).rgb;

        specular = 0.0; // PLANE não tem brilho
        lambert *= 0.5; //fica mais natural
    }
    else if ( object_id == DREAD )
    {
        vec4 bbox_center = (bbox_min + bbox_max) / 2.0;
        
        vec3 direction = position_model.xyz - bbox_center.xyz;
        
        float theta = atan(direction.z, direction.x);
        
        U = theta / (2.0 * M_PI) + 0.5;
        
        float height = bbox_max.y - bbox_min.y;
        V = (position_model.y - bbox_min.y) / height;

        specular *= 0.7;
        Kd0 = texture(TextureImage0, vec2(U,V)).rgb;

        
    }
    else if ( object_id == ORCMECH )
    {
        vec4 bbox_center = (bbox_min + bbox_max) / 2.0;
        
        vec3 direction = position_model.xyz - bbox_center.xyz;
        
        float theta = atan(direction.z, direction.x);
        
        U = theta / (2.0 * M_PI) + 0.5;
        
        float height = bbox_max.y - bbox_min.y;
        V = (position_model.y - bbox_min.y) / height;

        Kd0 = texture(TextureImage1, vec2(U,V)).rgb;

        specular = 0.0; // ORCMECH não tem brilho
    }
    else if ( object_id == RUIN )
    {
        float minx = bbox_min.x;
        float maxx = bbox_max.x;

        float miny = bbox_min.y;
        float maxy = bbox_max.y;

        // Flat mapping along the Z axis: project onto the XY plane
        U = (position_model.x - minx) / (maxx - minx);
        V = (position_model.y - miny) / (maxy - miny);

        Kd0 = texture(TextureImage3, vec2(U,V)).rgb;

        specular = 0.0; // RUIN não tem brilho

        
    }


    color.rgb = Kd0 * (lambert + 0.11) + vec3(1.0, 1.0, 1.0) * specular;

    // NOTE: If you want to render transparent objects, it is
    // necessary to:
    // 1) Enable the OpenGL "blending" operation just before
    // drawing the transparent objects, with the commands below in the C++ code:
    // glEnable(GL_BLEND);
    // glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    // 2) Draw all transparent objects *after* drawing
    // all opaque objects; and
    // 3) Draw transparent objects in order according to
    // their distance from the camera (drawing
    // transparent objects that are furthest from the camera first).
    // Alpha default = 1 = 100% opaque = 0% transparent
    color.a = 1;

    // Final color with gamma correction, considering sRGB monitor.
    // See https://en.wikipedia.org/w/index.php?title=Gamma_correction&oldid=751281772#Windows.2C_Mac.2C_sRGB_and_TV.2Fvideo_standard_gammas
    color.rgb = pow(color.rgb, vec3(1.0,1.0,1.0)/2.2);
} 

